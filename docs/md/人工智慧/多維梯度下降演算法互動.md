輸入 X = [1, 2, 3, 4]
標籤 y = [5, 7, 9, 11]
模型 y = wx + b
初始 w = 5
初始 b = 5

<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist@2.16.1"></script>
    <style>
        .input-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        input[type="number"] {
            background-color: transparent;
            border: none;
            border-bottom: 2px solid #F2BBFF;
            font-size: 16px;
            padding: 5px;
            width: 100px;
            text-align: center;
            outline: none;
        }
        input[type="number"]:focus {
            border-bottom-color: #F2BBFF;
        }
        .chart-container {
            width: 90%;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        #model2_output {
            font-size: 16px;
            white-space: pre-line;
        }
    </style>
</head>
<body>
    <div class="input-container">
        <label>學習率 (learning rate): <input type="number" id="model2_learningRate" value="0.01" step="0.01"></label>
        <label>最大迭代次數 (max iterations): <input type="number" id="model2_maxIterations" value="300" step="1"></label>
        <label>收斂條件 (tolerance): <input type="number" id="model2_tolerance" value="0.1" step="0.01"></label>
    </div>

    <div class="chart-container">
        <div id="model2_3d_chart"></div>
    </div>

    <p id="model2_output"></p>

    <script>
        function model2_runGradientDescent() {
            const outputDiv = document.getElementById('model2_output');
            outputDiv.innerHTML = ''; // 清空結果
            
            // 獲取用戶輸入的參數
            const learningRate = parseFloat(document.getElementById('model2_learningRate').value);
            const maxIterations = parseInt(document.getElementById('model2_maxIterations').value);
            const tolerance = parseFloat(document.getElementById('model2_tolerance').value);

            // 訓練數據
            const X = [1, 2, 3, 4];
            const y = [5, 7, 9, 11];

            let model2_w = 5, model2_b = 5;  // 初始值
            let model2_wVals = [model2_w];
            let model2_bVals = [model2_b];
            let model2_lossVals = [];
            let model2_iterationIndices = [];
            let model2_iteration = 0;

            // 用來存儲每次迭代的損失
            let resultText = `開始梯度下降:\n初始值 w = ${model2_w}, b = ${model2_b}, 學習率 = ${learningRate}, 最大迭代次數 = ${maxIterations}, 收斂條件 = ${tolerance}\n\n`;

            resultText += `計算: w_new = w - η * f'(w) ：\n`;

            while (model2_iteration < maxIterations) {
                const y_hat = X.map(xi => model2_w * xi + model2_b);
                const loss = y.reduce((sum, yi, i) => sum + Math.pow(y_hat[i] - yi, 2), 0);
                const grad_w = -2 * X.reduce((sum, xi, i) => sum + xi * (y[i] - y_hat[i]), 0);
                const grad_b = -2 * y.reduce((sum, yi, i) => sum + (yi - y_hat[i]), 0);

                model2_w -= learningRate * grad_w;
                model2_b -= learningRate * grad_b;

                model2_wVals.push(model2_w);
                model2_bVals.push(model2_b);
                model2_lossVals.push(loss);
                model2_iterationIndices.push(model2_iteration);

                if (Math.sqrt(grad_w**2 + grad_b**2) < tolerance) {
                    resultText += `梯度下降已收斂 ( 梯度 = ${Math.sqrt(grad_w**2 + grad_b**2).toFixed(6)} < ${tolerance} )，停止迭代。\n\n`;
                    break;
                }

                model2_iteration++;
            }

            resultText += `最終結果: w = ${model2_w.toFixed(6)}, b = ${model2_b.toFixed(6)}, 迭代次數 = ${model2_iteration}\n`;

            outputDiv.innerHTML = resultText.replace(/\n/g, "<br>");

            // 繪製 3D 圖表
            model2_draw3DChart(model2_wVals, model2_bVals, model2_lossVals);
        }

        // 使用 Plotly 繪製 3D 圖表
        function model2_draw3DChart(wVals, bVals, lossVals) {
            const trace1 = {
                x: wVals,
                y: bVals,
                z: lossVals,
                mode: 'markers',
                type: 'scatter3d',
                marker: { color: 'red', size: 5 }
            };
            const data = [trace1];

            const layout = {
                scene: {
                    xaxis: { title: 'Weight (w)' },
                    yaxis: { title: 'Bias (b)' },
                    zaxis: { title: 'Loss Value (loss)' },
                    camera: {
                        eye: {
                            x: -2, // 攝影機的 x 軸位置
                            y: -2, // 攝影機的 y 軸位置
                            z: 1.5  // 攝影機的 z 軸位置
                        }
                    }
                },
                title: ''
            };

            Plotly.newPlot('model2_3d_chart', data, layout);
        }


        // 監聽輸入框變化並重新計算
        document.querySelectorAll('.input-container input').forEach(input => {
            input.addEventListener('input', model2_runGradientDescent);
        });

        // 初次加載時運行梯度下降
        window.addEventListener('DOMContentLoaded', model2_runGradientDescent);
    </script>
</body>
</html>
(內容消失時請重新整理或按下f5)

