# 圖論

>題型整理：     
>1. 距離計算     
>[P-7-1. 探索距離](#p-7-1-探索距離)     
>[P-7-2. 開車蒐集寶物](#p-7-2-開車蒐集寶物)     
       


### BFS      

注意事項！！最常出錯的地方 ：一定要記得宣告vis陣列     
1. q.push後面會加上一個vis=true (所以共兩個)   
2. 判斷if(!vis[i]){ ... }
3. q是要取first


最基本寫法

```cpp
void bfs(int ff){

    queue<int>q;
    bool vis[N];
    
    q.push(ff);  
    vis[ff]=true;             //vis (1/3) push 後面加上一個 vis
    
    while(!q.empty()){
        int f=q.front();q.pop();
        for(int i:v[f]){ 
            if(!vis[i]){      //vis(2/3)
                q.push(i);
                vis[i]=true;  // vis(3/3) push 後面加上一個 vis

                cout<<i;      // 所有的點一定會被放入一次，所以在這處理要做的動作
            
            }
        }
    }
}
```



> 廣度優先，可以看成洪水擴散      
> 深藍是離開佇列的節點      
> 淺藍是走到的點      
> 綠色是加入佇列的點      

![alt text](../images/圖論/Sy-sMJl4a.gif)
<iframe width="718" height="404" src="https://www.youtube.com/embed/Yuq8PWRRvhU" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>  

> 步驟：    
> 1. 首先將第一個點加入佇列    
> 2. 接著走到第一個點（也就是佇列的第一個），將其子節點依序放入佇列    
> 3. 刪除佇列中第一個點    
>     
> 重複2~3直到佇列沒有東西(沒有下一個點)    


### 實作

> 在資料結構的部分我們需要：    
> 1. 存路徑的vector    
> 2. 存是否拜訪的陣列    
> 3. 一個queue儲存拜訪順序    
   
> 以上面的圖解為例   
      
輸入：      
第一行為節點數、路徑數（m）      
第二行為起點   
接下來有m行，為不同路徑   
```cpp
7 6
0
0 1
0 2
1 3
1 4
4 5
4 6
```
輸出：
```cpp
1 2 3 4 5 6
```
/// collapse-code  
```cpp     
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 1000
vector<int>v[N];

void bfs(int ff){
    queue<int>q;
    bool vis[N];
    q.push(ff);
    vis[ff]=true;             //vis (1/3)
    while(!q.empty()){
        int f=q.front();q.pop();
        for(int i:v[f]){ 
            if(!vis[i]){      //vis(2/3)
                vis[i]=true;  // vis(3/3)
                q.push(i);
                cout<<i;
            }
        }
    }
}

signed main(){
    istringstream cin("7 6 \
0 \
0 1 \
0 2 \
1 3 \
1 4 \
4 5 \
4 6");//123456
    int n,m;
    cin>>n>>m;
    int f;
    cin>>f;
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
    }
    bfs(f);
}
```
///

/// danger | 注意！！！
1. 有三處需要 vis     
2. vis在雙向圖、邊的起點與終點未必不同時必須加上     
///     
     
#### P-7-1. 探索距離
https://judge.tcirc.tw/ShowProblem?problemid=d090

P-7-1. 探索距離
輸入一個有向圖 G 與一個起點 s，請計算由 s 出發可以到達的點數(不包含 s)，並且計算這些可以到達的點與 s 的距離和，假設每個邊的長度均為 1。兩點之間可能有多個邊，邊的起點與終點未必不同。

Time limit: 1 秒

輸入格式：
第一行是兩個正整數 n 與 m，代表圖的點數與邊數，圖的點是以 0~n-1 編號，第二行是 s 的編號，接下來有 m 行，每一行兩個整數 a 與 b 代表一個邊(a,b)。n 不超過 100，m 不超過 4000。

輸出：
第一行輸出可以到達的點數，第二行輸出與 s 的距離總和。

範例輸入：     
7 6     
1     
5 1     
1 3     
1 4     
2 3     
4 6     
6 0     
         
    
範例輸出：    
4    
7    


> 這題比較困難的部分是如何計算高度    
>     
> 我們可以知道「子節點的高度」為「父節點的高度」+1    
> 所以`dp[子]=dp[父]+1    `
>
> 另外，這題不能用DFS，因為這是圖不是樹，最短距離要用BFS
    
    
/// collapse-code  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define nn "\n"
#define N 101
// istream& ss=cin;
// stringstream ss(" ");



vector<int>v[N];
int ans_1=0;
int ans_2=0;
int d[N]={0};
bool vis[N]={false};


void bfs(int a){
    queue <int>q;
    q.push(a);
    vis[a]=true;  //不要忘記！！！！
    d[a]=0;
    while(!q.empty()){
        int f=q.front();
        q.pop();
        for(int i:v[f]){
            if(!vis[i]){//不要忘記！！！！
                vis[i]=true;//不要忘記！！！！
                d[i]=d[f]+1;
                ans_1++;
                ans_2+=d[i];
                q.push(i);
            }
        }
    }
}



int main(){
    int n,m,a;
    cin>>n>>m>>a;
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
    }

    bfs(a);
    cout<<ans_1<<nn<<ans_2;
    return 0;
}
```
///




### DFS

/// html|div.i
最基本寫法

```cpp
void dfs(int f){
    vis[f]=true;       //標記為走過
    for(int i:v[f]){
        if(!vis[i]){   //排除走過的
            cout<<i;
            dfs(i);
        }
    }
    return;
}
```

///
> 能走多深就走多深，走不下去就回頭
![alt text](../images/圖論/H1BWlieE6.gif)
<iframe width="718" height="404" src="https://www.youtube.com/embed/rt5de19IbBA" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

> 做法：   
> 對於每個迭代到的節點進行迭代(遞迴)   
   
   
/// collapse-code  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 1000
vector<int>v[N];
bool vis[N];

void dfs(int f){
    vis[f]=true;
    for(int i:v[f]){
        if(!vis[i]){
            cout<<i;
            dfs(i);
        }
    }
    return;
}

signed main(){
    istringstream cin("7 6 \
0 \
0 1 \
0 2 \
1 3 \
1 4 \
4 5 \
4 6"); //134562
    int n,m;
    cin>>n>>m;
    int f;
    cin>>f;
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
    }
    dfs(f);
}
```
///
/// html | div.result
```
134562
```
///

#### P-7-2. 開車蒐集寶物
https://judge.tcirc.tw/ShowProblem?problemid=d091

參加一個蒐集寶物的遊戲，你拿到一個地圖，地圖上有 n 個藏寶點，每個藏寶點有若干價值的寶物，由於你的團隊是最頂尖的，只要能到達藏寶點一定可以取得該藏寶點的寶藏。從地圖上看得到一共有 m 條道路，每條道路連接兩個藏寶點，而且每條道路都是雙向可以通行的。在遊戲的一開始，你可以要求直升機將你的團隊運送到某個藏    
寶點，而且你可以獲得一部車與充足的油料，但是直升機的載送只有一次，所以你必須決定要從哪裡開始才可以獲得最多的寶藏總價值。    
    
Time limit: 1 秒    
    
輸入格式：    
第一行是兩個正整數 n 與 m，代表藏寶地點數與道路數，地點是以 0~n-1 編號，第二行 n 個非負整數，依序是每一個地點的寶藏價值，每個地點的寶藏價值不超過 100。接下來有 m 行，每一行兩個整數 a 與 b 代表一個道路連接的兩個地點編號。n 不超過 5e4，m 不超過 5e5。兩點之間可能有多條道路，有些道路的兩端點可能是同一地點。

輸出：    
最大可以獲得的寶藏總價值。    
    
    
     
> 注意vis就好     
> 因為有vis，所以每個點只會跑到一次。     
     
/// collapse-code  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define N int(5e5+10)
#define nn "\n"
vector<int>v[N];

int _sub=0;

int d[N];
int w[N];
int vis[N];
int ans=0;

int dfs(int f){
    vis[f]=true;
    for(int i:v[f]){
        if(!vis[i]){
            //cout<<f<<": "<<i<<nn;
            dfs(i);
            w[f]+=w[i];
        }
    }
}


int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    //istringstream cin("7 6 \
5 2 4 2 1 1 8 \
5 1 \
1 3 \
1 4 \
2 0 \
2 0 \
3 3");
    //istringstream cin("3 2 \
2 1 5 \
1 0 \
0 1");

    int n,m;
    cin>>n>>m;

    for(int i=0;i<n;i++){
        cin>>w[i];
    }

    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
        v[y].push_back(x);
    }

    for(int i=0;i<n;i++){
        if(!vis[i]){
            dfs(i);
            ans=max(ans,w[i]);
        }
    }
    cout<<ans;

}
```
///

### DAG 與 topological sort

> DAG:     
> DAG(directed acyclic graph)是指一種有向沒有環的圖     
>      
>      
> topological sort(拓樸順序):     
> 對於節點給予優先順序，像是先闖完哪一關才能到哪一關之類的     
     


     
>拓樸排序的方法:     
>     
>1. 找出所有in-degtee=的點放入陣列     
>2. 找到queue[head]的子節點，將他們的in-degtee減一，如果變成0，放入queue，將tail往後          
>3. 移動head往後      
>4. 一直重複2、3直到全部找完      
>      
>因為不一定是dag所以最後要檢查tail<n      
>    
>    
    
![alt text](../images/圖論/BJ5EkkeIT.gif)
<iframe width="718" height="404" src="https://www.youtube.com/embed/KRQPETKfJT0" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
``` title="input"
8 9    
0 1    
0 2    
2 3    
1 3    
1 4    
4 3    
4 5    
6 7    
7 5    
```    
    
/// html | div.result
```
0 6 1 2 7 4 3 5    
```    
///
/// collapse-code  
```cpp title="專業版"
#include<bits/stdc++.h>
using namespace std;
#define nn "\n"
#define N 10000

vector<int>v[N];

int topo[N]={0};
int indeg[N]={0};

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
        indeg[y]++;
    }

    int head=0,tail=0;

    for(int i=0;i<n;i++){
        if(indeg[i]==0){
            topo[tail]=i;
            tail++;
        }
    }
    for(int head=0;head<tail;head++){
        int f=topo[head];
        for(int i:v[f]){
            indeg[i]--;
            if(indeg[i]==0){
                topo[tail]=i;
                tail++;
            }
        }
    }

    if(tail<n){
        cout<<"not a dag";
    }
    else{
        for(int i=0;i<n;i++){
            cout<<topo[i]<<" ";
        }
    }
    
}
```
///

/// collapse-code  
```cpp title="自己寫"
#include <bits/stdc++.h>
using namespace std;
#define N 1000000

int inde[N]={0};
vector<int>v[N];
int main(){
    int n,m,total=0;
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        inde[y]++;
        v[x].push_back(y);
    }
    //bfs----------------
    queue<int>q;
    for(int i=0;i<n;i++){
        if(inde[i]==0){
            q.push(i);
            inde[i]--;
            cout<<i<<" ";
            total++;
        }
    }
    while(!q.empty()){
        int f=q.front();
        q.pop();
        for(int i:v[f]){
            inde[i]--;
            if(inde[i]==0){
                q.push(i);
                cout<<i<<" ";
                total++;
            }
        }
    }
    if(total<n){
        cout<<"not a dag";
    }
}
```
///

### 習題
         
#### d092: P-7-3. 機器人走棋盤 (APCS 201906)     
https://judge.hwsh.tc.edu.tw/ShowProblem?problemid=a121     
     
![alt text](../images/圖論/image-43.png)
> 此題利用了一個技巧：`int dn[4]={0,1,-1,0},dm[4]={1,0,0,-1};   `  
    
     
         
/// collapse-code  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define N 111
#define inf 2147483640
#define nn "\n"
int v[N][N];
int x,y;
int vis[N][N];
int n,m;
int ans=0;

int vv(int i,int j){
    if( (i<0 || i>=n)|| (j<0 || j>=m)    ){
        return inf;
    }
    return v[i][j];
}

int main(){
    //istringstream cin("\
4 5 \
24 7 14 20 30 \
11 6 4 21 29 \
2 8 1 35 40 \
3 9 5 12 15\
");
    //istringstream cin("2 7 \
6 8 7 2 1 4 5 \
9 3 10 11 12 13 14");
    int mi_element=inf;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>v[i][j];
            if(v[i][j]<mi_element){
                x=i;
                y=j;
                mi_element=v[i][j];
            }
        }
    }
    vis[x][y]=true;
    ans+=v[x][y];
    int ton[4]={0,1,0,-1};
    int tom[4]={1,0,-1,0};
    while(1){
        int mi=inf;
        int xx=-1,yy=-1;
        for(int i=0;i<4;i++){
            if(vv(x+ton[i],y+tom[i])<mi && !vis[x+ton[i]][y+tom[i]]){
                xx=x+ton[i];
                yy=y+tom[i];
                mi=vv(x+ton[i],y+tom[i]);
            }
        }
        if(mi==inf){
            cout<<ans;
            return 0;
        }
        x=xx;
        y=yy;
        vis[x][y]=true;
        ans+=vv(x,y);
    }
}
```
///

#### d093: P-7-4. 方格棋盤的最少轉彎數路線
https://judge.tcirc.tw/ShowProblem?problemid=d093


有一個 m*n 的方格棋盤，每個格子可能是 0 或 1，其中 0 代表可以通過而 1 代表不 能通過。現在有一個機器人從左上角編號(1,1)的格子出發，要到達右下角編號 (m,n)的格子，每次可以往上下左右四個方向移動，我們要找到轉彎次數最少的路線。 Time limit: 1 秒 

輸入格式：第一行是兩個正整數 m 與 n，代表格子棋盤的列數與行數，接下來有 m 行， 每行是一個長度為 n 僅由 0 與 1 組成的字串，代表方格棋盤由上往下由左至右的內 容，出發與目的格子必然是 0。m 與 n 不超過 500。 

輸出：最少的轉彎數。如果無法到達，則輸出-1。     
     
     
     
> 這一題可以發現他的輸入之間並沒有空格，如下：     
> 3 6     
> 001010     
> 101000         
> 100010              
         
> 所以沒辦法使用數字陣列一個一個位置輸入，除非想要先字串分析         
         
> 這邊使用了一個方法：              
> 宣告為字串陣列，一列一列輸入                  
> &v[i][1] 指的是每列開頭的指標              
> cin>>&v[i][1]就是將字串放入&v[i][1~n]              
          
> 第35行的while (v[ti][tj] == '0')是為了一直沿著直線一走下去，每一「批」直線是一組，dis[]相同，如下圖。        
        
![alt text](../images/圖論/SJMfnb6I6.gif)
<iframe width="718" height="404" src="https://www.youtube.com/embed/Nn1hIpeN3cI" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>


/// collapse-code  
```cpp  
#include <bits/stdc++.h>
using namespace std;
#define nn "\n"

istream &ss = cin;

// stringstream ss("3 6 001010 101000 100010");
struct st{
    int x;
    int y;
};
char v[501][501];
int dis[501][501];
int n, m;
int main(){
    ss >> n >> m;
    for (int i = 1; i <= m; i++){
        ss >> &v[i][1];
    }
    for (int i = 0; i < m + 2; i++){
        v[0][i] = '1';
        v[n + 1][i] = '1';
    }
    for (int i = 0; i < n + 2; i++){
        v[i][0] = '1';
        v[i][m + 1] = '1';
    }
    memset(dis, -1, sizeof(dis));
    // bfs
    st a = {1, 1};
    int di[4] = {0, 1, 0, -1}, dj[4] = {1, 0, -1, 0};
    queue<st> q;
    q.push({1, 1});
    dis[1][1] = 0;
    while (!q.empty() && dis[n][m] < 0){  //走完一條直線
        int fi = q.front().x, fj = q.front().y;
        q.pop();
        for (int i = 0; i < 4; i++){
            int ti = fi + di[i], tj = fj + dj[i];
            while (v[ti][tj] == '0'){
                if (dis[ti][tj] == -1){
                    dis[ti][tj] = dis[fi][fj] + 1;
                    q.push({ti, tj});
                }
                ti = ti + di[i], tj = tj + dj[i];
            }
        }
    }
    if (dis[n][m] > 0){
        dis[n][m]--;
    }

    cout << dis[n][m];
}
```
///

#### d094: Q-7-5. 闖關路線 (APCS201910)
https://judge.tcirc.tw/ShowProblem?problemid=d094

某個闖關遊戲上有一隻神奇寶貝與兩個可控制左右移動的按鍵。神奇寶貝被安置在僅可左右移動的滑軌上。滑軌分成 n 個位置，由左到右分別以 0 ~ n – 1 表示。當遊 戲開始時，神奇寶貝從位置 0 開始，遊戲的資訊包含 P、L 與 R 三個數字，其中 P 表 示所須移至的目標位置，L 與 R 則分別表示每按一次左鍵或右鍵後，會往左或往右移 動的格子數。此外，每一個位置 x 都對應一個瞬間移動位置 S(x)；每一次按鍵後， 神奇寶貝會先依據按鍵往左或右移動到某個位置 x，接著瞬間移動至 S(x)。某些點 的瞬間移動位置等同原地點，也就是 S(x) = x，這些點稱為停留點。開始與目標位 置都一定是停留點；此外，每個點的瞬間移動位置都一定是停留點(除非超出界外)， 也就是不會發生連續瞬間移動的情形。 遊戲的目標是以最少的按鍵數操作神奇寶貝由開始位置到達目標位置，此外，在移動 過程中不可以超過滑軌的範圍\[0, n – 1\]，否則算闖關失敗；某些點的瞬間移動位 置也可能會超出滑軌的範圍，移動到這些點也會導致闖關失敗。 

Time limit: 1 秒    

輸入格式：輸入有兩行，第一行有 4 個數字，第 1 個為 n，第 2 個為目標位置 P，第 3 個為 L，第 4 個為 R，後三個數字皆為小於 n 之正整數，且 2 ≤ n ≤ 1e6。第二 行有 n 個整數，依序是各點的瞬間移動位置 S(0), S(1), …, S(n – 1)，這些數 字是絕對值不超過 1e8 的整數。    

輸出：輸出到達目標位置所需的最少按鍵數，如果無法到達目標位置，則輸出 –1。     
     
     
> 這題直接使用BFS，透過d來存放步數，也就是計算樹的高度。     
> 而父節點的高度是子節點的高度+1，遞迴式：dp[子]=dp[父]+1     
>      
> 而左、右走之後直接「瞬移」，因為如果可以瞬移會直接瞬移，否則會停留在原地，而且     
> 瞬移不會算是一個「移動」。     






/// collapse-code  
```cpp  
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
const int maxn = 1000005;
int n, p, l, r, a[maxn], d[maxn], now, nxt;
  
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    while (cin >> n >> p >> l >> r) {
        for (int i = 0; i < n; i++){
        cin >> a[i];
        if (a[i] >= n || a[i] < 0) a[i] = n;
    }
    memset(d, -1, sizeof(d));
    d[0] = 0;
    queue <int> q;
    q.push(0);
    while (!q.empty() && d[p] == -1){
        now = q.front();
        q.pop();
        nxt = now - l;
        if (nxt >= 0 && a[nxt] != n && d[a[nxt]] == -1){
            d[a[nxt]] = d[now] + 1;
            q.push(a[nxt]);
        }
        nxt = now + r;
        if (nxt < n && a[nxt] != n && d[a[nxt]] == -1){
            d[a[nxt]] = d[now] + 1;
            q.push(a[nxt]);
        }
    }
    cout << d[p] << "\n";
    }
    return 0;
}
```

///


/// details | 錯誤版

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 10000001
#define nn "\n"


int d[N];

int s[N];
int n,p,l,r;


bool can(int a){
    if(a<n && a>=0 && d[a]==-1){//
        return true;
    }
    return false;
}

set<int>se;


int main(){
    
    cin>>n>>p>>l>>r;

    for(int i=0;i<n;i++){
        cin>>s[i];
    }

    //bfs;

    queue<int>q;
    memset(d,-1,sizeof(d));
    
    q.push(0);
    d[0]=0;


    while(!q.empty()){
        int f=q.front();
        //cout<<"f:"<<f<<"   ";
        q.pop();

        if(f==p){
            se.insert(d[f]);
        }
        if(can(s[f])){
            d[s[f]]=d[f];
            q.push(s[f]);
            //cout<<"s[f]:"<<s[f]<<" ";
        }

        if(can(f-l)){
            d[f-l]=d[f]+1;
            q.push(f-l);

            //cout<<"l:"<<f-l<<" ";
        }

        if(can(f+r)){
            d[f+r]=d[f]+1;
            q.push(f+r);

            //cout<<"r:"<<f+r<<" ";
        }
        cout<<nn;
    }
    int c=1;
    if(!se.empty()){
        cout<<*se.rend();
        c=0;
    }
    
    if(c){
        cout<<-1;
    }
    
}
```
///


    

![alt text](../images/圖論/image-44.png)
    
    
#### Q-7-7. AOV 最早完工時間

![alt text](../images/圖論/image-45.png)
     
範例一輸入：      
3 2      
1 3 4      
1 3      
2 3      
範例一輸出：      
7      
2 3     
         
範例二輸入：      
4 4      
1 2 3 4      
1 2       
1 3       
1 4       
3 4      
      
範例二輸出：       
8       
1 3 4      
      
      
    
    
    
> 這題可能會有多個根如例題1的1、2（應該說有拓樸的樹，因為多個根其實可以拉成一棵樹），因此我們要依照拓樸對於每一個根看看高度，再對於每個高度取max，再將max加總。    
    

    
/// collapse-code  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define N 100001
#define nn "\n"



int w[N]={0};
vector<int>v[N];
bool vis[N]={false};
queue<int>q;
int inde[N]={0};
int h[N]={0};
vector<pair<int,int>>v_h[N];


bool cmp(pair<int,int> a , pair<int,int> b){
    return  a.second > b.second;
}

//stringstream ss("3 2 1 3 4 1 3 2 3 ");
&istream  ss= cin;

int main(){
    int  n,m;
    ss>>n>>m;//工作數量、前置關係數
    for(int i=1;i<=n;i++){
        ss>>w[i];
    }
    for(int i=0;i<m;i++){
        int x,y;
        ss>>x>>y;
        inde[y]++;
        v[x].push_back(y);
    }
    for(int i=1;i<n;i++){
        if(inde[i]==0){
            h[i]=0;
            v_h[0].push_back({i,w[i]});
            q.push(i);
        }
    }


    while(!q.empty()){
        int f=q.front();
        q.pop();
        for(int i:v[f]){
            inde[i]--;
            if(inde[i]==0){
                h[i]=h[f]+1;
                v_h[h[i]].push_back({i,w[i]});
                q.push(i);
            }
        }
    }


    cout<<nn;

    for(int i=0;i<n;i++){
        sort(v_h[i].begin(),v_h[i].end(),cmp);
    }

    int all=0;

    int w=0;
    while(v_h[w].size()){
        all+=v_h[w][0].second;
        w++;
    }
    cout<<all<<nn;

    w=0;
    while(v_h[w].size()){
        cout<<v_h[w][0].first<<" ";
        w++;
    }
}

```
///
    
### Dijkstra 演算法用來計算一個圖中一點到其他點的最短路徑

延伸閱讀：https://hackmd.io/@cyk/shortest-path    
最短路徑發展：https://hackmd.io/@fdhscpp110/shortest_path

/// html | div.i

Dijkstra使用了鬆弛概念

鬆弛 Relax

作為圖論中的一個經典問題，求兩點間的最短路徑問題有個非常重要的核心概念，稱之為鬆弛 (Relax)：若目前從 \( a \) 到 \( b \) 的距離大於從 \( a \) 到 \( c \) 再從 \( c \) 到 \( b \) 的距離的話，則將其更新為較小值，即：

$$
d[a][b] = \min(d[a][b], d[a][c] + d[c][b])
$$
///

---


       
> Dijkstra演算法用來計算一個圖裡面一個起點對於其他點的最短路徑       
重要的是：    
> 路徑不能是負的    
       
[參考](https://www.youtube.com/watch?v=HHvjmLKJaxM)       
    
以此題為例    
    
P-7-9. 最短路徑 (*) 輸入一個無向圖 G=(V,E,w)，其中點以 0~n-1 編號，而邊的權重是非負整數。計算 0 號點到其他點的最短路徑長度。兩點之間可能有多個邊。 Time limit: 1 秒 輸入格式：第一行是兩個正整數 n 與 m，代表點數與邊數，接下來有 m 行，每行三個 整數 u, v, w 代表一條無向邊(u,v)的長度是 w。n 不超過 1e4，m 不超過 1e5, w 是不超過 1e4 的非負整數。 輸出：第一行輸出 0 到各點之最短路徑長度中的最大值，也就是在可以到達的點中， 最短距離最大的是多少，第二行輸出有多少點無法從抵達。

範例一輸入：      
7 6      
0 2 3      
0 1 1      
2 3 4      
1 4 0      
3 4 2      
5 4 3     
     
範例一輸出：      
4      
1     
      
範例二輸入：       
3 3       
2 1 5       
1 0 0       
0 1 1      
      
範例二輸出：       
5       
0      
            
範例一示意圖：      
![alt text](../images/圖論/Hk_ZVyZpa.png)
> Dijkstra 演算法
> 尋找步驟：      
> 1.找到起點的每個邊放入pq      
> 2.拿出最短的邊，此邊連線到的點的所有邊「未遇到的邊」放入pq，將此點標記為已遇到(已遇到：所有連接邊都放入pq過)    
> 3.重複第二點     

<iframe width="718" height="404" src="https://www.youtube.com/embed/O_AQIJtY3xE" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>




/// collapse-code  
```cpp  
#include<bits/stdc++.h>
using namespace std;
#define nn "\n"
#define N 1000000
struct st{
    int v, p;
};
vector<st>v[N];
int d[N];
int vis[N]={false};
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        v[x].push_back({y,z});
        v[y].push_back({x,z});
    }
    for(int i=0;i<n;i++){
        d[i]=N;
    }
    priority_queue<pair<int,int>>pq;
    pq.push({0,0});
    vis[0]=true;
    d[0]=0;
    while(!pq.empty()){
        auto f=pq.top();
        pq.pop();
        for(auto i:v[f.second]){
            vis[f.second]=true;
            if(!vis[i.v] && d[f.second]+i.p<d[i.v]){
                d[i.v]=d[f.second]+i.p;
                pq.push({-d[i.v],i.v});
            }
        }
    }
    int ans_1=0;
    int ans_2=0;
    for(int i=0;i<n;i++){
        if(d[i]==N){
            ans_2++;
        }
        else{
            ans_1=max(ans_1,d[i]);
        }
    }
    cout<<ans_1<<nn<<ans_2;
}
```

///

>與BFS差異
>![alt text](../images/圖論/image-50.png)

    
> 在第54行可以看到放入pq的條件是還沒遇到過而且路徑比原本少(比原本少是因為可能兩點間有多條路徑。
    
### 併查集    
> 當一個題目中有很多圖或是樹，要計算其中權重最大的圖的話可以用BFS或是DFS，這邊有一個新的方法，叫做併查集     
>     
> 這個概念就是對於每一個圖給一個「編號」，通常是根或是樹中最小的節點，不同圖分成很多國家的概念      
> 
> 併查集會用到兩個函式，分別為「合併」以及「找根節點」，先來看運作過程，以下題為例。    

---
    
P-7-2. 開車蒐集寶物    
參加一個蒐集寶物的遊戲，你拿到一個地圖，地圖上有 n 個藏寶點，每個藏寶點有若    
干價值的寶物，由於你的團隊是最頂尖的，只要能到達藏寶點一定可以取得該藏寶點    
的寶藏。從地圖上看得到一共有 m 條道路，每條道路連接兩個藏寶點，而且每條道路    
都是雙向可以通行的。在遊戲的一開始，你可以要求直升機將你的團隊運送到某個藏    
寶點，而且你可以獲得一部車與充足的油料，但是直升機的載送只有一次，所以你必    
須決定要從哪裡開始才可以獲得最多的寶藏總價值。    
Time limit: 1 秒    
輸入格式：第一行是兩個正整數 n 與 m，代表藏寶地點數與道路數，地點是以 0~n-1編號，第二行 n 個非負整數，依序是每一個地點的寶藏價值，每個地點的寶藏價值     
不超過 100。接下來有 m 行，每一行兩個整數 a 與 b 代表一個道路連接的兩個地點     
編號。n 不超過 5e4，m 不超過 5e5。兩點之間可能有多條道路，有些道路的兩端點     
可能是同一地點。     
輸出：最大可以獲得的寶藏總價值。     
     
              
範例一輸入：     
7 6     
5 2 4 2 1 1 8     
5 1     
1 3     
1 4     
2 0     
2 0     
3 3     
範例一輸出：     
9     
    


以範例一為例：   
![alt text](../images/圖論/B1lQIK86T.gif)
<iframe width="718" height="404" src="https://www.youtube.com/embed/q_k2AT5BjX4" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    


    
    
/// collapse-code  
```cpp title="專業"
#include<bits/stdc++.h>
using namespace std;
#define nn "\n"
#define nnn " "
#define N 100000

istringstream ss("7 6 \
5 2 4 2 1 1 8 \
5 1 \
1 3 \
1 4 \
2 0 \
2 0 \
3 3 \
");
int p[N];// 小於0時是數量，大於0是根結點編號

// 找根節點
int r(int u) {
    if (p[u] < 0) return u;
    return p[u] = r(p[u]);
}

int main() {
    int m, n, w[N];
    ss>>n>>m;;//printf("%d: ",n);
    for (int i=0; i<n; i++){
        ss>>w[i];// 輸入權重
    }
    for (int i=0; i<n; i++){
        p[i] = -1; // 初始化為-1
    }
    for (int i=0; i<m; i++) { // 輸入每個邊，對於每個邊動作
        int r1,r2,x,y;
        ss>>x>>y;
        r1 = r(x); // root of u
        r2 = r(y); // root of v
        if (r1==r2) continue; // 如果相同根結點一樣
        if (p[r1] < p[r2]) {// 如果我的根的人數比你多
            p[r1] += p[r2];  // 第一個的人數(負數)加上第二個的人數(負數)
            p[r2] = r1;  // 第二個的根結點改成第一個
            w[r1] += w[r2];
        } else {
            p[r2] += p[r1];
            p[r1] = r2;
            w[r2] += w[r1];
        }
    }
    cout<<*max_element(w,w+n);
}
```
///

/// collapse-code  
```cpp title="自己寫"
#include <bits/stdc++.h>
using namespace std;
#define N 100000
int w[N];
int f[N]; //N為社長時，回傳社團人數。N為社員時，回傳社長 

int leader(int x){ //找到社長
    if(f[x]<0){
        return x;
    }
    return f[x]=leader(f[x]);
}

int main(){
    int n,m;
    cin>>n>>m;    
    for(int i=0;i<n;i++){
        cin>>w[i];
        f[i]=-1;
    }
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        int r1=leader(x),r2=rfind(y);  //社長1、社長2
        if(r1==r2)continue;          //如果社長相同就不動作
        if(f[r1]>f[r2])swap(r1,r2);  //讓第一社長人數較多
        f[r1]+=f[r2];                //第一社長加上第二社長人數
        f[r2]=r1;                    //第二社長交接給第一社長
        w[r1]+=w[r2];
    }
    cout<<*max_element(w,w+n);
}
```
///

#### 練習題：[a445. 新手訓練系列- 我的朋友很少](https://zerojudge.tw/ShowProblem?problemid=a445)


/// collapse-code  
```cpp title="程式碼"
#include<bits/stdc++.h>
using namespace std;


vector<int>f;

int leader(int x){
    if(f[x]<0){
        return x;
    }
    return f[x]=leader(f[x]);
}



int main(){
    
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    int n,m,t;
    cin>>n>>m>>t;

    f.resize(n+1,-1);
    for(int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;

        int r1=leader(x);
        int r2=leader(y);

        if(r1==r2)continue;

        if(f[r1]>f[r2])swap(r1,r2);

        f[r1]+=f[r2];

        f[r2]=r1;
    }
    for(int i=0;i<t;i++){
        int x,y;
        cin>>x>>y;
        int r1=leader(x);
        int r2=leader(y);


        if(r1==r2)cout<<":)"<<"\n";
        else cout<<":("<<"\n";
    }
}
```
///


#### 練習題：[d831. 畢業旅行](https://zerojudge.tw/ShowProblem?problemid=d831)


/// collapse-code  
```cpp title="程式碼"
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define nn "\n"
int n,m;
vector<int>f;
int r(int x){
    if(f[x]<0)return x;
    return f[x]=r(f[x]);
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    //istringstream cin("6 4 \
0 1 \
2 3 \
1 3 \
5 4 \
1000000 0 \
1000000 1 \
0 999999");
    while(cin>>n>>m){
        f.clear();
        f.resize(n+1,-1);
        for(int i=0;i<m;i++){
            int a,b;
            cin>>a>>b;
            int ra=r(a),rb=r(b);
            if(ra==rb)continue;
            if(f[ra]>f[rb])swap(ra,rb);
            f[ra]+=f[rb];
            f[rb]=ra;
        }
        int mi=0;
        for(int i:f){
            mi=min(mi,i);
        }
        cout<<-mi<<nn;
    }
}
```
///

#### 練習題：[d449. 垃圾信件](https://zerojudge.tw/ShowProblem?problemid=d449)


/// collapse-code  
```cpp title="程式碼"
#include <bits/stdc++.h>
using namespace std;
#define int long long 
#define nn "\n"
#define N 10005


int n,m,i,x,a,b,ra,rb,root;
unordered_set<int> s[N];
int f[N];

int r(int x){
    if(f[x]==x)return x;

    s[f[x]].erase(x);
    f[x]=r(f[x]);
    s[f[x]].insert(x);


    return f[x];
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    //istringstream cin("4 4 \
1 1 2 \
1 3 4 \
1 1 3 \
2 3");

    while(cin>>n>>m){
        for( i=1;i<=n;i++){
            f[i]=i;
            s[i].clear();
        }
        for( i=0;i<m;i++){
            cin>>x;
            if(x&1){
                cin>>a>>b;
                
                ra=r(a);
                rb=r(b);

                if(ra==rb)continue;
                f[rb]=ra;
                s[ra].insert(rb);
            }
            else{
                cin>>a;
                if(f[a]==a){
                    if (s[a].size() == 0) continue;
                    root=*s[a].begin();

                    f[root]=root;
                    f[a]=a;

                    for(int i:s[a]){
                        if(i==root)continue;
                        s[root].insert(i);
                        f[i]=root;
                    }
                    s[a].clear();
                }
                else{
                    root=r(a);

                    for(int i:s[a]){
                        s[root].insert(i);
                        f[i]=root;
                    }
                    s[a].clear();
                    s[f[root]].erase(a);

                    f[a]=a;
                }
            }
        }
        int ans=0;
        for(int i=1;i<=n;i++){
            if(f[i]==i){
                ans++;
            }
        }
        cout<<ans<<nn;
    }
}
```
///




### 最小生成樹
                              
> 在一個地圖中有很多條連線，需要將其變成一顆樹(沒有環)而且要路徑最小的演算法，稱為最小生成樹。
                              
                              

#### P-7-12. 最小生成樹 (*)      
輸入一個無向圖 G=(V,E,w)，其中點以 0~n-1 編號，而邊的權重是非負整數。計算      
G 的最小生成樹的成本。兩點之間可能有多個邊。      
Time limit: 1 秒      
輸入格式：第一行是兩個正整數 n 與 m，代表點數與邊數，接下來有 m 行，每行三個      
整數 u, v, w 代表一條無向邊(u,v)的長度是 w。n 不超過 1e4，m 不超過 1e5, w      
是不超過 1e4 的非負整數。              
輸出：輸出最小生成樹的成本，如果不存在則輸出-1。        
範例一輸入：        
8 10        
0 1 6     
0 2 4     
1 2 5     
2 3 9     
1 4 1            
1 5 1            
2 6 2       
4 5 3       
5 6 8       
7 6 1       
範例一輸出：       
23       
       
                                           
> 以此題為例             
> 如下圖：      
                                    
                                  
![alt text](../images/圖論/B1nySSAyA.gif)
<iframe width="718" height="404" src="https://www.youtube.com/embed/Ty4e-heQn7U" title="BFS" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
     
> 要找出最小生成樹有兩種方法：     
     
#### 法一：併查集(最小生成樹)     
            
> 將路徑按照權重排序後一一取出，如果連線的兩個點已經在同一集合，代表會形成環，丟棄(略過)即可。       
>        
> /// danger |    注意  
> 其實就是在併查集的基礎上把路徑先排序再使用而已       
> ///
       

/// collapse-code  
```cpp  
#include <bits/stdc++.h>
using namespace std;
#define nn "\n"
#define N 100000
istream& ss=cin;
int f[N];
int p[N];
struct st{
    int x;
    int y;
};
int r(int x){
    if(f[x]<0){
        return x;
    }
    return f[x]=r(f[x]);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int ans=0;
    int t=0;
    int w,s;
    ss>>s>>w;
    for(int i=0;i<s;i++){
        f[i]=-1;
        p[i]=0;
    }
    priority_queue<pair<int,pair<int,int>>>pq;
    //power,value,value
    for(int i=0;i<w;i++){
        int x,y,z;
        ss>>x>>y>>z;
        pq.push({-z,{x,y}});
    }
    while(!pq.empty()){
        int r1=r(pq.top().second.first);
        int r2=r(pq.top().second.second);
        int pow=-pq.top().first;
        pq.pop();
        if(r1==r2){
            continue;
        }
        if(f[r1]<f[r2]){
            f[r1]+=f[r2];
            f[r2]=r1;
            ans+=pow;
            t++;
        }
        else{
            f[r2]+=f[r1];
            f[r1]=r2;
            ans+=pow;
            t++;
        }
    }
    if(t<s-1){
        cout<<"-1";
        return 0;
    }
    cout<<ans;
}
```
///



#### 法二：Dijkstra-演算法


> 使用這方法找出所有最短路徑，最後加在一起。     
>      
> ///danger | 注意     
> 在54、55行只需要比較 i.p<d[i.v] 即可，因為它比原本大就好。     
> ///     
     
     

/// collapse-code  
```cpp  
#include <bits/stdc++.h>
using namespace std;


#define nn "\n"
#define N 1000000

istream& ss=cin;
//stringstream ss("8 10 \
0 1 6 \
0 2 4 \
1 2 5 \
2 3 9 \
1 4 1 \
1 5 1 \
2 6 2 \
4 5 3 \
5 6 8 \
7 6 1");


struct st{
    int v,p;
};


vector<st> v[N];

bool vis[N]={false};
int d[N];

int main(){
    int n,m;
    ss>>n>>m;
    for(int i=0;i<n;i++){
        d[i]=N;
    }
    for(int i=0;i<m;i++){
        int x,y,z;
        ss>>x>>y>>z;
        v[x].push_back({y,z});
        v[y].push_back({x,z});
    }
    
    priority_queue<pair<int,int>>pq;
    pq.push({0,0});
    d[0]=0;
    
    while(!pq.empty()){
        pair<int,int> f=pq.top();
        pq.pop();
        vis[f.second]=true;
        for(st i:v[f.second]){
            if(!vis[i.v] && i.p<d[i.v]){
                d[i.v]=i.p;
                pq.push({-d[i.v],i.v});
            }
        }
    }
    int ans=0;
    for(int i=0;i<n;i++){
        if(d[i]==N){
            cout<<-1;
            return 0;
        }
        else{
            ans+=d[i];
        }
    }
    cout<<ans;
}
```
///